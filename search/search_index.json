{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ridgeplot-py docs","text":"<p>This is a simple module for plotting ridgeplot with the scipy ecosystem.</p> <p>Ridgeplot is a great data visualization technique to compare distributions from multiple groups at the same time, and was first introduced in 2017 as joy plot:</p> <p>I hereby propose that we call these \"joy plots\" #rstats https://t.co/uuLGpQLAwY</p>\u2014 Jenny Bryan (@JennyBryan) April 25, 2017 <p>ridgeplot-py provides a simple API to produce matplotlib-compatible ridgeplots, as well as a handy ColorEncoder class with scikit-learn syntax for manipulating color annotations in a consistent way [through out manuscripts or presentations].</p>"},{"location":"#modules","title":"Modules","text":"<ol> <li>colors</li> <li>ridgeplot</li> <li>stats</li> <li>dotted_heatmap</li> </ol>"},{"location":"colors/","title":"ridgeplot.colors","text":"<p>This module collects functions for manipulating color legends for matplotlib plots and a collections of color palettes.</p>"},{"location":"colors/#src.ridgeplot.colors.ColorEncoder","title":"<code>ColorEncoder</code>","text":"<p>color-encoding a categoric vector</p> Example <pre><code>&gt;&gt;&gt; from ridgeplot.colors import ColorEncoder, ColorPalette\n&gt;&gt;&gt; categorical_vector = ['group a','group b','group c','group a']\n&gt;&gt;&gt; colors = ColorPalette[\"okabeito\"]\n&gt;&gt;&gt; ce = ColorEncoder()\n&gt;&gt;&gt; ce.fit(categorical_vector, colors)\n&gt;&gt;&gt; ce.encoder\nOrderedDict([('group a', '#E69F00'),\n     ('group b', '#56B4E9'),\n     ('group c', '#009E73')])\n&gt;&gt;&gt; ce.transform([\"group b\", \"group c\", \"group a\"])\n['#56B4E9', '#009E73', '#E69F00']\n</code></pre> or <pre><code>&gt;&gt;&gt; ce = ColorEncoder()\n&gt;&gt;&gt; ce.fit_transform(categorical_vector, colors)\n['#E69F00', '#56B4E9', '#009E73', '#E69F00']\n</code></pre> access color encoder <pre><code>&gt;&gt;&gt; ce.encoder\nOrderedDict([('group a', '#E69F00'),\n     ('group b', '#56B4E9'),\n     ('group c', '#009E73')])\n</code></pre> Source code in <code>src/ridgeplot/colors.py</code> <pre><code>class ColorEncoder:\n    \"\"\"\n    color-encoding a categoric vector\n\n    Example:\n        ```\n        &gt;&gt;&gt; from ridgeplot.colors import ColorEncoder, ColorPalette\n        &gt;&gt;&gt; categorical_vector = ['group a','group b','group c','group a']\n        &gt;&gt;&gt; colors = ColorPalette[\"okabeito\"]\n        &gt;&gt;&gt; ce = ColorEncoder()\n        &gt;&gt;&gt; ce.fit(categorical_vector, colors)\n        &gt;&gt;&gt; ce.encoder\n        OrderedDict([('group a', '#E69F00'),\n             ('group b', '#56B4E9'),\n             ('group c', '#009E73')])\n        &gt;&gt;&gt; ce.transform([\"group b\", \"group c\", \"group a\"])\n        ['#56B4E9', '#009E73', '#E69F00']\n        ```\n\n    or:\n        ```\n        &gt;&gt;&gt; ce = ColorEncoder()\n        &gt;&gt;&gt; ce.fit_transform(categorical_vector, colors)\n        ['#E69F00', '#56B4E9', '#009E73', '#E69F00']\n        ```\n\n    access color encoder:\n        ```\n        &gt;&gt;&gt; ce.encoder\n        OrderedDict([('group a', '#E69F00'),\n             ('group b', '#56B4E9'),\n             ('group c', '#009E73')])\n        ```\n    \"\"\"\n\n    def __init__(self):\n        self.x: List[str] = list()\n        self.distinct_categories: List[str] = []\n        self.encoder: OrderedDict[str, str] = OrderedDict()\n\n    def fit(self, categories: List[str], colors: List[str] = ColorPalette[\"invitae\"]) -&gt; None:\n        \"\"\"\n        mapping colors to the unique categories in the input list\n        basically fill the encoder dictionary\n\n        Example:\n            ```\n            &gt;&gt;&gt; categorical_vector = ['group a','group b','group c','group a']\n            &gt;&gt;&gt; colors = ColorPalette[\"okabeito\"]\n            &gt;&gt;&gt; ce = ColorEncoder()\n            &gt;&gt;&gt; ce.fit(categroical_vector, colors)\n            ```\n\n        Args:\n            categories: list of input values (i.e. labels of the samples), can be duplicated\n            colors: list of colors, intentionally not checked for duplication\n        Returns:\n            NoneType\n        \"\"\"\n        self.distinct_categories = check_color_vector_size(categories, colors)\n        self.encoder = OrderedDict({category: col for category, col in zip(self.distinct_categories, colors)})\n\n    def transform(self, categories: List[str]) -&gt; List[str]:\n        \"\"\"\n        mapping color to the a list of category in the input list\n\n        Example:\n            ```\n            &gt;&gt;&gt; categorical_vector = ['group a','group b','group c','group a']\n            &gt;&gt;&gt; colors = ColorPalette[\"okabeito\"]\n            &gt;&gt;&gt; ce = color_encoder()\n            &gt;&gt;&gt; ce.fit(categroical_vector, colors)\n            &gt;&gt;&gt; new_categorical_vector = [\"group b\", \"group c\"]\n            &gt;&gt;&gt; ce.transform(new_categorical_vector)\n            ['#56B4E9', '#009E73']\n            ```\n\n        Args:\n            categories: list of input values (i.e. labels of the samples), can be duplicated\n        Returns:\n            list of colors for the input list according to the fitted color encoder\n        \"\"\"\n        if not self.encoder:\n            raise ValueError(\"Call color_encoder.fit() first!!\")\n\n        union_set = set(self.distinct_categories).union(set(categories))\n        if len(union_set) != len(self.distinct_categories):\n            unseen = union_set - set(self.distinct_categories)\n            unseen_str = \", \".join(sorted(list(unseen)))\n            raise ValueError(f\"Input [categories] contain unseen data!!: {unseen_str}\")\n\n        return [self.encoder[category] for category in categories]\n\n    def fit_transform(self, categories: List[str], colors: List[str] = ColorPalette[\"invitae\"]) -&gt; List[str]:\n        \"\"\"\n        first map the color to the categories, and then return the\n        corresponding color for each category in the input list\n\n        Example:\n            ```\n            &gt;&gt;&gt; categorical_vector = [\"group1\", \"group2\", \"group1\"]\n            &gt;&gt;&gt; colors = [\"salmon\",\"gold\"]\n            &gt;&gt;&gt; ce = ColorEncoder()\n            &gt;&gt;&gt; ce.fit_transform(categorical_vector, colors)\n            ['salmon', 'gold', 'salmon']\n            ```\n\n        Args:\n            categories: list of input values (i.e. labels of the samples), can be duplicated\n            colors: list of colors to be assigned to the categories\n        Returns:\n            list of colors corresponding to the input\n        \"\"\"\n        self.fit(categories, colors=colors)\n        return self.transform(categories)\n\n    def show_legend(\n        self,\n        ax: matplotlib.axes._axes.Axes,\n        sort: bool = False,\n        **kwargs: Dict[str, Any],\n    ) -&gt; legend.Legend:\n        \"\"\"\n        Adding matplotlib legend describing the color encoder to a matplotlib ax object\n\n        Args:\n            ax: matplotlib ax object\n            sort: sort the legend by the category\n            **kwargs: keyword arguments for matplotlib.pyplot.legend\n\n        Returns:\n            the matplotlib legend object\n        \"\"\"\n\n        if sort:\n            self.encoder = OrderedDict(sorted(self.encoder.items(), key=lambda item: item[0]))\n        pat = [mpatches.Patch(color=col, label=lab) for lab, col in self.encoder.items()]\n        lgd = ax.legend(handles=pat, **kwargs)\n        return lgd\n</code></pre>"},{"location":"colors/#src.ridgeplot.colors.ColorEncoder.fit","title":"<code>fit(categories, colors=ColorPalette['invitae'])</code>","text":"<p>mapping colors to the unique categories in the input list basically fill the encoder dictionary</p> Example <pre><code>&gt;&gt;&gt; categorical_vector = ['group a','group b','group c','group a']\n&gt;&gt;&gt; colors = ColorPalette[\"okabeito\"]\n&gt;&gt;&gt; ce = ColorEncoder()\n&gt;&gt;&gt; ce.fit(categroical_vector, colors)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>List[str]</code> <p>list of input values (i.e. labels of the samples), can be duplicated</p> required <code>colors</code> <code>List[str]</code> <p>list of colors, intentionally not checked for duplication</p> <code>ColorPalette['invitae']</code> <p>Returns:     NoneType</p> Source code in <code>src/ridgeplot/colors.py</code> <pre><code>def fit(self, categories: List[str], colors: List[str] = ColorPalette[\"invitae\"]) -&gt; None:\n    \"\"\"\n    mapping colors to the unique categories in the input list\n    basically fill the encoder dictionary\n\n    Example:\n        ```\n        &gt;&gt;&gt; categorical_vector = ['group a','group b','group c','group a']\n        &gt;&gt;&gt; colors = ColorPalette[\"okabeito\"]\n        &gt;&gt;&gt; ce = ColorEncoder()\n        &gt;&gt;&gt; ce.fit(categroical_vector, colors)\n        ```\n\n    Args:\n        categories: list of input values (i.e. labels of the samples), can be duplicated\n        colors: list of colors, intentionally not checked for duplication\n    Returns:\n        NoneType\n    \"\"\"\n    self.distinct_categories = check_color_vector_size(categories, colors)\n    self.encoder = OrderedDict({category: col for category, col in zip(self.distinct_categories, colors)})\n</code></pre>"},{"location":"colors/#src.ridgeplot.colors.ColorEncoder.fit_transform","title":"<code>fit_transform(categories, colors=ColorPalette['invitae'])</code>","text":"<p>first map the color to the categories, and then return the corresponding color for each category in the input list</p> Example <pre><code>&gt;&gt;&gt; categorical_vector = [\"group1\", \"group2\", \"group1\"]\n&gt;&gt;&gt; colors = [\"salmon\",\"gold\"]\n&gt;&gt;&gt; ce = ColorEncoder()\n&gt;&gt;&gt; ce.fit_transform(categorical_vector, colors)\n['salmon', 'gold', 'salmon']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>List[str]</code> <p>list of input values (i.e. labels of the samples), can be duplicated</p> required <code>colors</code> <code>List[str]</code> <p>list of colors to be assigned to the categories</p> <code>ColorPalette['invitae']</code> <p>Returns:     list of colors corresponding to the input</p> Source code in <code>src/ridgeplot/colors.py</code> <pre><code>def fit_transform(self, categories: List[str], colors: List[str] = ColorPalette[\"invitae\"]) -&gt; List[str]:\n    \"\"\"\n    first map the color to the categories, and then return the\n    corresponding color for each category in the input list\n\n    Example:\n        ```\n        &gt;&gt;&gt; categorical_vector = [\"group1\", \"group2\", \"group1\"]\n        &gt;&gt;&gt; colors = [\"salmon\",\"gold\"]\n        &gt;&gt;&gt; ce = ColorEncoder()\n        &gt;&gt;&gt; ce.fit_transform(categorical_vector, colors)\n        ['salmon', 'gold', 'salmon']\n        ```\n\n    Args:\n        categories: list of input values (i.e. labels of the samples), can be duplicated\n        colors: list of colors to be assigned to the categories\n    Returns:\n        list of colors corresponding to the input\n    \"\"\"\n    self.fit(categories, colors=colors)\n    return self.transform(categories)\n</code></pre>"},{"location":"colors/#src.ridgeplot.colors.ColorEncoder.show_legend","title":"<code>show_legend(ax, sort=False, **kwargs)</code>","text":"<p>Adding matplotlib legend describing the color encoder to a matplotlib ax object</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>matplotlib ax object</p> required <code>sort</code> <code>bool</code> <p>sort the legend by the category</p> <code>False</code> <code>**kwargs</code> <code>Dict[str, Any]</code> <p>keyword arguments for matplotlib.pyplot.legend</p> <code>{}</code> <p>Returns:</p> Type Description <code>Legend</code> <p>the matplotlib legend object</p> Source code in <code>src/ridgeplot/colors.py</code> <pre><code>def show_legend(\n    self,\n    ax: matplotlib.axes._axes.Axes,\n    sort: bool = False,\n    **kwargs: Dict[str, Any],\n) -&gt; legend.Legend:\n    \"\"\"\n    Adding matplotlib legend describing the color encoder to a matplotlib ax object\n\n    Args:\n        ax: matplotlib ax object\n        sort: sort the legend by the category\n        **kwargs: keyword arguments for matplotlib.pyplot.legend\n\n    Returns:\n        the matplotlib legend object\n    \"\"\"\n\n    if sort:\n        self.encoder = OrderedDict(sorted(self.encoder.items(), key=lambda item: item[0]))\n    pat = [mpatches.Patch(color=col, label=lab) for lab, col in self.encoder.items()]\n    lgd = ax.legend(handles=pat, **kwargs)\n    return lgd\n</code></pre>"},{"location":"colors/#src.ridgeplot.colors.ColorEncoder.transform","title":"<code>transform(categories)</code>","text":"<p>mapping color to the a list of category in the input list</p> Example <pre><code>&gt;&gt;&gt; categorical_vector = ['group a','group b','group c','group a']\n&gt;&gt;&gt; colors = ColorPalette[\"okabeito\"]\n&gt;&gt;&gt; ce = color_encoder()\n&gt;&gt;&gt; ce.fit(categroical_vector, colors)\n&gt;&gt;&gt; new_categorical_vector = [\"group b\", \"group c\"]\n&gt;&gt;&gt; ce.transform(new_categorical_vector)\n['#56B4E9', '#009E73']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>List[str]</code> <p>list of input values (i.e. labels of the samples), can be duplicated</p> required <p>Returns:     list of colors for the input list according to the fitted color encoder</p> Source code in <code>src/ridgeplot/colors.py</code> <pre><code>def transform(self, categories: List[str]) -&gt; List[str]:\n    \"\"\"\n    mapping color to the a list of category in the input list\n\n    Example:\n        ```\n        &gt;&gt;&gt; categorical_vector = ['group a','group b','group c','group a']\n        &gt;&gt;&gt; colors = ColorPalette[\"okabeito\"]\n        &gt;&gt;&gt; ce = color_encoder()\n        &gt;&gt;&gt; ce.fit(categroical_vector, colors)\n        &gt;&gt;&gt; new_categorical_vector = [\"group b\", \"group c\"]\n        &gt;&gt;&gt; ce.transform(new_categorical_vector)\n        ['#56B4E9', '#009E73']\n        ```\n\n    Args:\n        categories: list of input values (i.e. labels of the samples), can be duplicated\n    Returns:\n        list of colors for the input list according to the fitted color encoder\n    \"\"\"\n    if not self.encoder:\n        raise ValueError(\"Call color_encoder.fit() first!!\")\n\n    union_set = set(self.distinct_categories).union(set(categories))\n    if len(union_set) != len(self.distinct_categories):\n        unseen = union_set - set(self.distinct_categories)\n        unseen_str = \", \".join(sorted(list(unseen)))\n        raise ValueError(f\"Input [categories] contain unseen data!!: {unseen_str}\")\n\n    return [self.encoder[category] for category in categories]\n</code></pre>"},{"location":"colors/#src.ridgeplot.colors.check_color_vector_size","title":"<code>check_color_vector_size(categorical_vector, color_vector)</code>","text":"<p>asserting the number of different categories in the input list is less than the given color list</p> <p>Parameters:</p> Name Type Description Default <code>categorical_vector</code> <code>List[str]</code> <p>list of input values (i.e. labels of the samples), can be duplicated</p> required <code>color_vector</code> <code>List[str]</code> <p>list of colors, intentionally not checked for duplication</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>list of unique categories in the input list</p> Source code in <code>src/ridgeplot/colors.py</code> <pre><code>def check_color_vector_size(categorical_vector: List[str], color_vector: List[str]) -&gt; List[str]:\n    \"\"\"\n    asserting the number of different categories in the input list is less than the given color list\n\n    Args:\n        categorical_vector: list of input values (i.e. labels of the samples), can be duplicated\n        color_vector: list of colors, intentionally not checked for duplication\n\n    Returns:\n        list of unique categories in the input list\n    \"\"\"\n    categories = ordered_set(categorical_vector)\n\n    if len(categories) &gt; len(color_vector):\n        raise ValueError(f\"Not enough colors!! {len(color_vector)} colors for {len(categories)} categories\")\n    return categories\n</code></pre>"},{"location":"colors/#src.ridgeplot.colors.get_cmap_color_values","title":"<code>get_cmap_color_values(cmap_name)</code>","text":"<p>Get color values for the min and max color in a color map</p> <p>Parameters:</p> Name Type Description Default <code>cmap_name</code> <code>str</code> <p>color map name (e.g. viridis)</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>hex code for the min and max color</p> Source code in <code>src/ridgeplot/colors.py</code> <pre><code>def get_cmap_color_values(cmap_name: str) -&gt; Tuple[str, str]:\n    \"\"\"\n    Get color values for the min and max color in a color map\n\n    Args:\n        cmap_name: color map name (e.g. viridis)\n\n    Returns:\n        hex code for the min and max color\n    \"\"\"\n    cmap = get_cmap(cmap_name)\n    return to_hex(cmap(0.0)), to_hex(cmap(1.0))\n</code></pre>"},{"location":"colors/#src.ridgeplot.colors.ordered_set","title":"<code>ordered_set(xs)</code>","text":"<p>this is a simple function to make a set according to the order of the input list</p> <p>because python set is unordered, see:     https://stackoverflow.com/questions/9792664/converting-a-list-to-a-set-changes-element-order</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>List[str]</code> <p>list of input values</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>a list of unique input values in the order of how they arranged in the input list</p> Source code in <code>src/ridgeplot/colors.py</code> <pre><code>def ordered_set(xs: List[str]) -&gt; List[str]:\n    \"\"\"\n    this is a simple function to make a set according to the order of the input list\n\n    because python set is unordered, see:\n        https://stackoverflow.com/questions/9792664/converting-a-list-to-a-set-changes-element-order\n\n    Args:\n        xs: list of input values\n\n    Returns:\n        a list of unique input values in the order of how they arranged in the input list\n    \"\"\"  # noqa: E501\n    xs = list(xs)\n    return sorted(set(xs), key=xs.index)\n</code></pre>"},{"location":"dotted_heatmap/","title":"ridgeplot.dotted_heatmap","text":"<p>for most of the part, this is copied from: https://stackoverflow.com/questions/59381273/heatmap-with-circles-indicating-size-of-population</p>"},{"location":"dotted_heatmap/#src.ridgeplot.dotted_heatmap.dotted_heatmap","title":"<code>dotted_heatmap(data, ax, cmap='cividis', circle_size=None)</code>","text":"<p>Plotting dotted heatmap</p> Example <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from ridgeplot.dotted_heatmap import dotted_heatmap\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; data = pd.DataFrame(\n...    np.random.randn(n, n),\n...    index=[f\"feature{i}\" for i in range(n)],\n...    columns=[f\"sample{i}\" for i in range(n)],\n... )\n&gt;&gt;&gt; dotted_heatmap(data=data,ax=ax, cmap=\"viridis\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>data to plot</p> required <code>ax</code> <code>Axes</code> <p>matplotlib ax object</p> required <code>cmap</code> <code>str</code> <p>cmap value, defaults to \"cividis\"</p> <code>'cividis'</code> <code>circle_size</code> <code>Optional[float]</code> <p>raidus of the circles, if None, we will use relaive sizes, defaults to None</p> <code>None</code> Source code in <code>src/ridgeplot/dotted_heatmap.py</code> <pre><code>def dotted_heatmap(\n    data: pd.DataFrame,\n    ax: matplotlib.axes._axes.Axes,\n    cmap: str = \"cividis\",\n    circle_size: Optional[float] = None,\n):\n    \"\"\"\n    Plotting dotted heatmap\n\n    Example:\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from ridgeplot.dotted_heatmap import dotted_heatmap\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; data = pd.DataFrame(\n        ...    np.random.randn(n, n),\n        ...    index=[f\"feature{i}\" for i in range(n)],\n        ...    columns=[f\"sample{i}\" for i in range(n)],\n        ... )\n        &gt;&gt;&gt; dotted_heatmap(data=data,ax=ax, cmap=\"viridis\")\n        ```\n\n    Args:\n        data: data to plot\n        ax: matplotlib ax object\n        cmap: cmap value, defaults to \"cividis\"\n        circle_size: raidus of the circles,\n            if None, we will use relaive sizes, defaults to None\n    \"\"\"\n    nrows, ncols = data.shape\n    x, y = np.meshgrid(np.arange(ncols), np.arange(nrows))\n    radii = data.values / 2 / data.values.max()\n    # radius is relative if circle_size is None\n    circles = [\n        plt.Circle((j, i), radius=circle_size if circle_size is not None else r)\n        for r, j, i in zip(radii.flat, x.flat, y.flat)\n    ]\n    col = PatchCollection(circles, array=data.values.flatten(), cmap=cmap)\n    ax.add_collection(col)\n\n    ax.set_xticks(np.arange(ncols))\n    ax.set_xticklabels(data.columns)\n    ax.set_yticks(np.arange(nrows))\n    ax.set_yticklabels(data.index)\n\n    ax.set_xticks(np.arange(ncols + 1) - 0.5, minor=True)\n    ax.set_yticks(np.arange(nrows + 1) - 0.5, minor=True)\n    ax.grid(which=\"minor\", alpha=0.5, color=\"white\")\n    ax.tick_params(left=False, bottom=False)\n    for d in [\"top\", \"bottom\", \"left\", \"right\"]:\n        ax.spines[d].set(alpha=0.5)\n    plt.colorbar(col)\n</code></pre>"},{"location":"ridge_plot/","title":"ridgeplot.ridge_plot","text":"<p>This module contains the main function to plot ridgeplots.</p>"},{"location":"ridge_plot/#src.ridgeplot.ridge_plot.ridgeplot","title":"<code>ridgeplot(ax, data, xlim=None, fill_colors=None, line_colors=None, label_size=10.0, fill_alpha=0.5)</code>","text":"<p>plotting a ridgeplot</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from ridgeplot.ridge_plot import ridgeplot\n\n&gt;&gt;&gt; data = {}\n&gt;&gt;&gt; for i in range(10):\n&gt;&gt;&gt;    data['data_{}'.format(i)] = np.random.randn(100) * (i+1)\n\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; ridgeplot(ax, data, xlim=(-20,20))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>a matplotlib ax object for writing the plot</p> required <code>data</code> <code>dict[str, list[float]]</code> <p>a dictionary of data, key is the label of the group, values are the data values in the group</p> required <code>xlim</code> <code>Optional[tuple[float, float]]</code> <p>x-limits for the plot (xmin, xmax)</p> <code>None</code> <code>fill_colors</code> <code>Optional[list[str]]</code> <p>colors for the fill under the distribution, must be same length as input data (default: all steelblue)</p> <code>None</code> <code>line_colors</code> <code>Optional[list[str]]</code> <p>colors for the line drawing the distribution, must be same length as input data (default: all white)</p> <code>None</code> <code>label_size</code> <code>float</code> <p>label size of the name of each distribution</p> <code>10.0</code> <code>fill_alpha</code> <code>float</code> <p>alpha value for the fill under the distribution (default: 0.5)</p> <code>0.5</code> <p>Returns:</p> Type Description <code>None</code> <p>NoneType</p> Source code in <code>src/ridgeplot/ridge_plot.py</code> <pre><code>def ridgeplot(\n    ax: matplotlib.axes._axes.Axes,\n    data: dict[str, list[float]],\n    xlim: Optional[tuple[float, float]] = None,\n    fill_colors: Optional[list[str]] = None,\n    line_colors: Optional[list[str]] = None,\n    label_size: float = 10.0,\n    fill_alpha: float = 0.5,\n) -&gt; None:\n    \"\"\"\n    plotting a ridgeplot\n\n    Example:\n        ```\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from ridgeplot.ridge_plot import ridgeplot\n\n        &gt;&gt;&gt; data = {}\n        &gt;&gt;&gt; for i in range(10):\n        &gt;&gt;&gt;    data['data_{}'.format(i)] = np.random.randn(100) * (i+1)\n\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; ridgeplot(ax, data, xlim=(-20,20))\n        ```\n\n    Args:\n        ax: a matplotlib ax object for writing the plot\n        data: a dictionary of data, key is the label of\n            the group, values are the data values in the group\n        xlim: x-limits for the plot (xmin, xmax)\n        fill_colors: colors for the fill under the distribution,\n            must be same length as input data (default: all steelblue)\n        line_colors: colors for the line drawing the distribution,\n            must be same length as input data (default: all white)\n        label_size: label size of the name of each distribution\n        fill_alpha: alpha value for the fill under the distribution (default: 0.5)\n\n    Returns:\n        NoneType\n    \"\"\"\n\n    # assigning colors if not given\n    if fill_colors is None:\n        fill_colors = len(data) * [\"steelblue\"]\n\n    if line_colors is None:\n        line_colors = len(data) * [\"white\"]\n\n    # assigning xlims if not given\n    if xlim is not None:\n        xmin, xmax = xlim\n    else:\n        xmin = min(first(data.values()))\n        xmax = max(first(data.values()))\n\n    # data validation\n    if len(fill_colors) != len(data):\n        raise RidgePlotError(\"fill_colors must be same length as data\")\n\n    if len(line_colors) != len(data):\n        raise RidgePlotError(\"line_colors must be same length as data\")\n\n    xlines = []\n    for sample_number, (data_key, data_values) in enumerate(data.items()):\n        data_values_array = np.array(data_values, dtype=\"float\")\n        xs = np.arange(xmin, xmax * 1.1, 0.01)  # xaxis is 10% wider than data max\n        kde = gaussian_kde(data_values_array)\n\n        baseline = -sample_number * 0.7\n        ys = scaling(kde.pdf(xs)) + baseline\n        ax.plot(xs, ys, color=line_colors[sample_number], lw=2)\n        ax.fill_between(x=xs, y1=ys, y2=baseline, color=fill_colors[sample_number], alpha=fill_alpha)\n        xlines.append(baseline)\n        ax.text(xmin, baseline, data_key, ha=\"right\", va=\"bottom\", fontsize=label_size)\n    # ax.hlines(xlines, xmin=xmin, xmax=xmax * 1.1, color=\"black\", lw=1)\n    ax.legend(loc=\"center\").set_visible(False)\n    ax.get_yaxis().set_visible(False)\n    for side in [\"left\", \"right\", \"top\"]:\n        ax.spines[side].set_visible(False)\n    ax.set_xlim(xmin, xmax)\n</code></pre>"},{"location":"stats/","title":"ridgeplot.stats","text":""},{"location":"stats/#src.ridgeplot.stats.scaling","title":"<code>scaling(x)</code>","text":"<p>scaling a vector to a range between 0 and 1</p> Example <pre><code>&gt;&gt;&gt; scaling([1,2,3,4])\narray([0.        , 0.33333333, 0.66666667, 1.        ])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>List[float]</code> <p>list of data values (float)</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>An numpy array of the scaled values</p> Source code in <code>src/ridgeplot/stats.py</code> <pre><code>def scaling(x: List[float]) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    scaling a vector to a range between 0 and 1\n\n    Example:\n        ```\n        &gt;&gt;&gt; scaling([1,2,3,4])\n        array([0.        , 0.33333333, 0.66666667, 1.        ])\n        ```\n\n    Args:\n        x: list of data values (float)\n\n    Returns:\n        An numpy array of the scaled values\n    \"\"\"\n    np_x = np.array(x, dtype=\"float\")\n\n    if len(np.unique(np_x)) == 1:\n        raise ValueError(\"The input list should not be homogenous\")\n\n    np_x = (np_x - np_x.min()) / (np_x.max() - np_x.min())\n    return np_x\n</code></pre>"}]}